const fs = require("fs");
const path = require("path");
const util = require("util");

const readFileAsync = util.promisify(fs.readFile);
const writeFileAsync = util.promisify(fs.writeFile);

const lunr = require("lunr");
const { html2text, getDocVersion } = require("./parse");
const { logger } = require("./logger");

const flatMap = (array, mapper) => {
  return array.reduce((acc, element) => {
    return acc.concat(mapper(element));
  }, []);
};

// FIXME: Duplicated in src/theme/SearchBar/util.js
function urlMatchesPrefix(url, prefix) {
  if (prefix.endsWith("/")) {
    throw new Error(`prefix must not end with a /. This is a bug.`);
  }
  return url === prefix || url.startsWith(`${prefix}/`);
}

module.exports = function (context, options) {
  let blogBasePath =
    options.blogRouteBasePath !== undefined
      ? options.blogRouteBasePath
      : "/blog";
  let docsBasePath =
    options.docsRouteBasePath !== undefined
      ? options.docsRouteBasePath
      : "/docs";
  const indexPages =
    options.indexPages !== undefined ? options.indexPages : false;
  const indexBlog = options.indexBlog !== undefined ? options.indexBlog : true;
  const indexDocs = options.indexDocs !== undefined ? options.indexDocs : true;
  let language = options.language !== undefined ? options.language : "en";

  if (Array.isArray(language) && language.length === 1) {
    language = language[0];
  }

  if (!blogBasePath.startsWith("/")) {
    throw new Error(
      `blogBasePath must start with /, received: '${blogBasePath}'.`
    );
  }
  if (!docsBasePath.startsWith("/")) {
    throw new Error(
      `docsBasePath must start with /, received: '${docsBasePath}'.`
    );
  }
  blogBasePath = blogBasePath.substr(1);
  docsBasePath = docsBasePath.substr(1);

  const docsDir = path.resolve(context.siteDir, "docs");
  let docVersions = [];
  let useDocVersioning = false;
  if (!fs.existsSync(docsDir)) {
    logger.info(
      `Skipping search index generation for documentation because directory ${docsDir} does not exist.`
    );
  } else {
    const versionsPath = path.join(docsDir, "..", "versions.json");
    if (fs.existsSync(versionsPath)) {
      useDocVersioning = true;
      docVersions = [
        ...JSON.parse(fs.readFileSync(versionsPath, "utf-8")),
        "next",
      ];
      logger.info(
        `The following documentation versions were detected: ${docVersions.join(
          ", "
        )}`
      );
    } else {
      logger.info(
        `The documentation is not versioned (${versionsPath} does not exist).`
      );
    }
  }

  let generated =
    "// THIS FILE IS AUTOGENERATED\n" +
    "// DO NOT EDIT THIS FILE!\n\n" +
    'import * as lunr from "lunr";\n';

  function handleLangCode(code) {
    let generated = "";

    if (code === "jp") {
      throw new Error(`Language "jp" is deprecated, please use "ja".`);
    }

    if (code === "ja") {
      require("lunr-languages/tinyseg")(lunr);
      generated += `require("lunr-languages/tinyseg")(lunr);\n`;
    }
    require(`lunr-languages/lunr.${code}`)(lunr);
    generated += `require("lunr-languages/lunr.${code}")(lunr);\n`;

    return generated;
  }

  if (language !== "en") {
    require("lunr-languages/lunr.stemmer.support")(lunr);
    generated += 'require("lunr-languages/lunr.stemmer.support")(lunr);\n';
    if (Array.isArray(language)) {
      language
        .filter((code) => code !== "en")
        .forEach((code) => {
          generated += handleLangCode(code);
        });
      require("lunr-languages/lunr.multi")(lunr);
      generated += `require("lunr-languages/lunr.multi")(lunr);\n`;
    } else {
      generated += handleLangCode(language);
    }
  }
  if (language === "ja" || language === "th") {
    generated += `\
export const tokenize = (input) => lunr['${language}'].tokenizer(input)
  .map(token => token.str);\n`;
  } else {
    generated += `\
export const tokenize = (input) => input
  .split(" ")
  .map((each) => each.trim().toLowerCase())
  .filter((each) => each.length > 0);\n`;
  }
  generated += `export default lunr;\n`;
  generated += `export const docsBasePath = ${JSON.stringify(docsBasePath)};\n`;
  generated += `export const blogBasePath = ${JSON.stringify(blogBasePath)};\n`;

  const generatedPath = path.join(__dirname, "generated.js");
  fs.writeFileSync(generatedPath, generated);

  return {
    name: "@cmfcmf/docusaurus-search-local",
    getThemePath() {
      return path.resolve(__dirname, "./theme");
    },
    async postBuild({ routesPaths = [], outDir, baseUrl }) {
      logger.info("Gathering documents");

      const data = flatMap(routesPaths, (url) => {
        if (!url.startsWith(baseUrl)) {
          throw new Error(
            `The route must start with the baseUrl ${baseUrl}, but was ${route}. This is a bug, please report it.`
          );
        }
        const route = url.substr(baseUrl.length);
        if (route === "404.html") {
          // Do not index error page.
          return [];
        }
        if (indexBlog && urlMatchesPrefix(route, blogBasePath)) {
          if (
            route === blogBasePath ||
            urlMatchesPrefix(route, `${blogBasePath}/tags`)
          ) {
            // Do not index list of blog posts and tags filter pages
            return [];
          }
          return { route, url, type: "blog" };
        }
        if (indexDocs && urlMatchesPrefix(route, docsBasePath)) {
          return { route, url, type: "docs" };
        }
        if (indexPages) {
          return { route, url, type: "page" };
        }
        return [];
      }).map(({ route, url, type }) => {
        const file = path.join(outDir, route, "index.html");
        return {
          file,
          url,
          type,
        };
      });

      logger.info("Parsing documents");

      // Give every index entry a unique id so that the index does not need to store long URLs.
      let nextDocId = 1;
      const documents = (
        await Promise.all(
          data.map(async ({ file, url, type }) => {
            logger.debug(`Parsing ${type} file ${file}`, { url });
            const html = await readFileAsync(file, { encoding: "utf8" });
            const { pageTitle, sections } = html2text(html, type, url);
            const docVersion = getDocVersion(html);

            return sections.map((section) => ({
              id: nextDocId++,
              pageTitle,
              pageRoute: url,
              sectionRoute: url + section.hash,
              sectionTitle: section.title,
              sectionContent: section.content,
              docVersion,
            }));
          })
        )
      ).reduce((acc, val) => acc.concat(val), []); // .flat()

      logger.info("Building index");

      const index = lunr(function () {
        if (language !== "en") {
          if (Array.isArray(language)) {
            this.use(lunr.multiLanguage(...language));
          } else {
            this.use(lunr[language]);
          }
        }
        this.ref("id");
        this.field("title");
        this.field("content");
        if (useDocVersioning) {
          this.field("version");
        }
        documents.forEach(function ({
          id,
          sectionTitle,
          sectionContent,
          docVersion,
        }) {
          const indexDoc = {
            id: id.toString(), // the ref must be a string
            title: sectionTitle,
            content: sectionContent,
          };
          if (useDocVersioning) {
            // Default to the latest version if the page has no docVersion.
            // This will make blog posts and pages searchable when searching
            // for the latest doc version.
            indexDoc.version = docVersion ? docVersion : docVersions[0];
          }
          this.add(indexDoc);
        },
        this);
      });

      logger.info("Writing index to disk");

      await writeFileAsync(
        path.join(outDir, "search-index.json"),
        JSON.stringify({
          documents: documents.map(
            ({ id, pageTitle, sectionTitle, sectionRoute, docVersion }) => ({
              id,
              pageTitle,
              sectionTitle,
              sectionRoute,
              // Only include docVersion metadata if versioning is used
              docVersion: useDocVersioning ? docVersion : undefined,
            })
          ),
          index,
        }),
        { encoding: "utf8" }
      );

      logger.info("Index written to disk, success!");
    },
  };
};
